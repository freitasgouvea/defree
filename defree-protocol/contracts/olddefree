pragma solidity 0.6.12;

import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";  
import "openzeppelin-solidity/contracts/lifecycle/Pausable.sol";  
import { IERC20 } from "./IERC20.sol";

contract Defree is Ownable, Pausable {

    mapping(address => uint256) public deFreeBalance;
    mapping(address => uint256) public deFreeTicket;
    
    uint256 public balanceOfDefree;
    uint256 public actualTicket;

    event DepositDefree (address indexed from, uint256 indexed ticket, uint256 amount);

    function depositDefree (IERC20 token, uint256 amount) public {
        require(token.transferFrom(msg.sender, this.address, amount));
        deFreeBalance[msg.sender] = amount;
        deFreeTicket[msg.sender] = actualTicket + 1;
        balanceOfDefree = balanceOfDefree + amount;
        emit DepositDefree(msg.sender, actualTicket + 1, amount);
    }

    /*
    function depositDefi (address lendingPoolAddress, address tokenAddress, uint256 amount) {
        require(balanceOfDefree >= 10000);
        LendingPoolAddressesProvider provider = LendingPoolAddressesProvider(address(lendingPoolAddress));
        LendingPool lendingPool = LendingPool(provider.getLendingPool());
        address tokenAddress = address(tokenAddress);
        uint256 amount = 1000 * 1e18;
        uint16 referral = 0;
        IERC20(tokenAddress).approve(provider.getLendingPoolCore(), amount);
        lendingPool.deposit(tokenAddress, amount, referral);
    }

    function repayDefi () {

    }

    function returnAllBalanceToOwners () {

    }
    */

}





//SPDX-License-Identifier: MIT

pragma solidity 0.7.3;

import "./imports.sol";

contract DefreeUSDCAAVE is Ownable, Pausable {
    
    address DefreePoolWallet;

    struct OpenApproval{
        uint id;
        address owner;
        uint256 amount;
    } //(livro de ordens)
    
    struct AaveDeposit{
        uint id;
        address owner;
        uint256 amount;
        uint256 deadline;
    } //(livro de depositos)
    
    mapping(address => uint) public approvalsMap;  
    mapping(address => uint) public depositsMap; 
    
    OpenApproval[] public approvals;
    AaveDeposit[] public deposits;
    
    IERC20 public ERC20Interface;
    
    ILendingPoolAddressesProvider aaveProvider;
    ILendingPool aaveLendingPool;
    address aaveLendingPoolCore;
    address USDCAddress;
    
    event DepositSuccessful(address indexed from_, address indexed to_, uint256 amount_);  
    
    constructor(address lendingPoolAddressesProvider, address USDCAddress_) public {
        DefreePoolWallet = msg.sender;
        aaveProvider = ILendingPoolAddressesProvider(lendingPoolAddressesProvider);
        aaveLendingPool = ILendingPool(aaveProvider.getLendingPool());
        aaveLendingPoolCore = aaveProvider.getLendingPoolCore();
        USDCAddress = USDCAddress_;
    }
    
    function registryApprove(uint256 _amount) public whenNotPaused {
        ERC20Interface = IERC20(USDCAddress);
        TransferHelper.safeApprove(address(USDCAddress), aaveLendingPoolCore, _amount);
        //bytes32 approveId = keccak256(abi.encodePacked(msg.sender, block.timestamp));
        OpenApproval memory OA = OpenApproval(approveId, msg.sender, _amount);
        approvalsMap[msg.sender] = OA;
    }
    
    function depositAave(uint256 _deadline) public onlyOwner whenNotPaused {
        ERC20Interface = IERC20(USDCAddress);
        for (uint i=0; i<approvals.length; i++) {
            TransferHelper.safeApprove(address(USDCAddress), aaveLendingPoolCore, approvals[i].amount);
            aaveLendingPool.deposit(address(USDCAddress), approvals[i].amount, 0);
            bytes32 depositId = keccak256(abi.encodePacked(approvals[i].owner, block.timestamp));
            AaveDeposit memory AD = AaveDeposit(depositId, approvals[i].owner, approvals[i].amount, _deadline);
            depositsMap[approvals[i].owner] = AD;
            emit DepositSuccessful(approvals[i].owner, aaveLendingPoolCore, approvals[i].amount);
            //delete
        }
    }
    
    receive() payable external {}
    
}